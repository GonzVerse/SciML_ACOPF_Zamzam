# AC Optimal Power Flow using Neural Networks
## Implementation of Zamzam et al. (2019) Method

This repository implements the neural network-based approach for solving AC Optimal Power Flow (OPF) problems as described in:

> **Zamzam, A. S., & Baker, K. (2019).** "Learning Optimal Solutions for Extremely Fast AC Optimal Power Flow." *arXiv:1910.01213*

---

## ğŸ“‹ Overview

The code demonstrates a machine learning approach to solve AC OPF problems on millisecond timescales by:
1. Training a neural network to predict generator setpoints from load demands
2. Using power flow recovery to ensure feasibility
3. Achieving significant speedup compared to traditional optimization solvers

**Key Features:**
- âœ… Pure implementation of Zamzam's Algorithm 1
- âœ… Î±/Î² parameterization for bounded outputs
- âœ… R-ACOPF training data generation
- âœ… Two-stage power flow recovery for feasibility
- âœ… Comprehensive evaluation metrics
- âœ… Detailed analysis and visualization tools

---

## ğŸš€ Quick Start

### Installation (3 Steps)

1. **Clone repository**
```bash
git clone <your-repo-url>
cd Version-3
```

2. **Install dependencies**
```bash
pip install -r requirements.txt
```

3. **Run pipeline**
```bash
python run_all.py
```

**That's it!** Results will be in `Outputs_V3/` after ~2-3 hours.

ğŸ‘‰ **See [QUICKSTART.md](QUICKSTART.md) for detailed installation guide and troubleshooting.**

---

### Manual Execution (Step-by-Step)

For debugging or partial runs, execute scripts individually:

```bash
# 1. Generate training/test data (~45 min)
python 00_generate_opf_data_pypower.py

# 2. Train the neural network (~20 min with GPU)
python 02_train_opf_network_v3_improved.py

# 3. Recover full AC OPF solutions
python 03_power_flow_recovery.py

# 4. Evaluate optimality and feasibility
python 04_evaluate_with_metrics.py

# 5. Analyze Qg correction process
python 05_analyze_qg_correction.py

# 6. Explain correction step-by-step
python 06_explain_correction_process.py

# 7. Sensitivity analysis (optional)
python 07_sensitivity_analysis_qg_filtering.py
```

---

## ğŸ“ Repository Structure

```
Version 3/
â”œâ”€â”€ 00_generate_opf_data_pypower.py       # Generate R-ACOPF training data
â”œâ”€â”€ 02_train_opf_network_v3_improved.py   # Train NN (Zamzam architecture)
â”œâ”€â”€ 03_power_flow_recovery.py             # Algorithm 1 implementation
â”œâ”€â”€ 04_evaluate_with_metrics.py           # Compute performance metrics
â”œâ”€â”€ 05_analyze_qg_correction.py           # Analyze Qg violations
â”œâ”€â”€ 06_explain_correction_process.py      # Step-by-step correction demo
â”œâ”€â”€ 07_sensitivity_analysis_qg_filtering.py # Data quality analysis
â”œâ”€â”€ 08_COMPREHENSIVE_SUMMARY.md           # Detailed methodology
â”œâ”€â”€ README.md                             # This file
â”œâ”€â”€ requirements.txt                      # Python dependencies
â”œâ”€â”€ LICENSE                               # License information
â””â”€â”€ Outputs_V3/                           # Generated outputs (not in repo)
    â”œâ”€â”€ generator_limits.json
    â”œâ”€â”€ opf_case57_train_v2.csv
    â”œâ”€â”€ opf_case57_test_v2.csv
    â”œâ”€â”€ best_opf_model_v3_improved.pth
    â”œâ”€â”€ recovery_results_v3.csv
    â””â”€â”€ *.png (visualizations)
```

---

## ğŸ¯ Key Results

### IEEE 57-Bus Test System

| Metric | Our Result | Zamzam (2019) |
|--------|-----------|---------------|
| **Î´_q (Qg violation)** | 0.967 MVAr | 1.58 MVAr |
| **Optimality Gap** | < 0.5% | 0.46% |
| **Inference Time** | 0.061 ms | ~1 ms |
| **Total Time (NN + PF)** | 17.98 ms | 211 ms |


---

## ğŸ§  Method Overview

### Neural Network Architecture
- **Input:** Load demands (Pd, Qd) at all buses
- **Output:** Î± (active power parameters) and Î² (voltage parameters)
- **Structure:** 3 hidden layers with sigmoid activations
- **Output layer:** Sigmoid (enforces [0,1] bounds)

### Parameterization
Generator outputs are parameterized to ensure constraint satisfaction:
```
Pg = Pg_min + Î± Ã— (Pg_max - Pg_min)
Vm = Vm_min + Î² Ã— (Vm_max - Vm_min)
```

### Training Data: R-ACOPF
To ensure interior solutions, training data is generated by solving:
```
minimize   Î£ cost(Pg)
subject to:
  - Standard OPF constraints
  - Vm_min + Î» â‰¤ Vm â‰¤ Vm_max - Î»  (voltage margin)
```

### Power Flow Recovery (Algorithm 1)

1. **NN Prediction:** Î±, Î² = NN(Pd, Qd)
2. **Convert to Physical:** Pg, Vm = convert(Î±, Î²)
3. **Initial Power Flow:** Solve for Qg, Va with fixed Pg, Vm
4. **Check Violations:** If Qg violates limits, clip to bounds
5. **Modified Power Flow:** Re-solve with fixed Qg, released Vm

---

## ğŸ“Š Evaluation Metrics

### Zamzam Metric: Î´_q
Average reactive power violation magnitude:
```
Î´_q = (1/T) Î£ (1/|G|) ||Î¾_q||â‚‚
```
where Î¾_q captures violations: max{Qmin - Qg, 0} + max{Qg - Qmax, 0}

### Optimality Gap
```
gap = [cost(NN solution) - cost(OPF solution)] / cost(OPF solution)
```

### Feasibility
Maximum power balance equation residual:
```
max ||h(v, p, q)||â‚‚
```

---

## ğŸ” Understanding Qg Violations

**Why do they occur?**
- NN predicts Pg and Vm, not Qg directly
- Qg is determined by power flow equations (physics)
- Network topology and loads affect Qg

**Why is this expected?**
- This is the DESIGNED behavior in Zamzam's method
- The two-stage correction ensures feasibility
- Final solution satisfies all constraints

**See:** `06_explain_correction_process.py` for detailed walkthrough

---

## ğŸ¨ Visualizations

The code generates several visualizations:

1. **Training Curves** (`training_curves_v3_improved.png`)
   - Loss progression
   - Validation metrics

2. **Recovery Analysis** (`recovery_analysis_v3.png`)
   - Success rates
   - Recovery time distribution
   - Qg violation statistics
   - Speedup comparison

3. **Qg Correction Details** (`qg_correction_detailed_analysis.png`)
   - Per-generator violation analysis
   - Violation magnitude distribution

4. **Correction Process** (`qg_correction_process_gen*.png`)
   - Step-by-step visualization of Algorithm 1
   - Before/after comparison

---

## âš™ï¸ Configuration

Key parameters in scripts:

### Data Generation (`00_generate_opf_data_pypower.py`)
```python
NUM_TRAINING_SAMPLES = 100000
NUM_TEST_SAMPLES = 10000
LAMBDA_MARGIN = 0.005  # Voltage margin for R-ACOPF
MAX_LOAD_DEVIATION = 0.7  # Â±70% from base load
```

### Training (`02_train_opf_network_v3_improved.py`)
```python
BATCH_SIZE = 256
LEARNING_RATE = 0.001
NUM_EPOCHS = 300
LAMBDA_MSE = 1.0  # Pure MSE loss (Zamzam approach)
```

### Power Flow Recovery (`03_power_flow_recovery.py`)
```python
# Timing measurements
single_sample_timing = True  # Accurate deployment timing
batch_size = 32  # For batch timing comparison
num_timing_samples = 100  # Number of samples to time
```

---

## ğŸ“ˆ Performance Analysis

### Speedup Attribution

Our 18 ms total time vs Zamzam's 211 ms breaks down as:

| Component | Ours | Zamzam | Difference |
|-----------|------|--------|------------|
| NN Inference | 0.061 ms | ~1 ms | ~0.94 ms |
| Power Flow | 17.92 ms | ~210 ms | ~192 ms |
| **Total** | **17.98 ms** | **211 ms** | **193 ms** |

**Key Insight:** 99.5% of speedup comes from PyPower's faster power flow solver compared to MATPOWER.

### Hardware Considerations
- Results may vary based on CPU, BLAS library (OpenBLAS vs MKL)
- GPU acceleration available for NN inference (minimal impact due to small network)
- Power flow solving is CPU-bound (single-threaded)

---

## ğŸ› Troubleshooting

### Common Issues

**1. "Generator limits not found"**
- Run `00_generate_opf_data_pypower.py` first
- Check that `Outputs_V3/generator_limits.json` exists

**2. "Model checkpoint not found"**
- Run `02_train_opf_network_v3_improved.py` to train model
- Check that `Outputs_V3/best_opf_model_v3_improved.pth` exists

**3. Power flow convergence failures**
- Check Î» parameter (too large may cause infeasibility)
- Verify PyPower installation
- Examine load profile deviations

**4. High Qg violations**
- Expected behavior! See `06_explain_correction_process.py`
- Check Î´_q metric (< 2 MVAr is good for IEEE 57-bus)
- Review training data quality

---

## ğŸ“š References

### Primary Paper
```bibtex
@article{zamzam2019learning,
  title={Learning Optimal Solutions for Extremely Fast AC Optimal Power Flow},
  author={Zamzam, Ahmed S and Baker, Kyri},
  journal={arXiv preprint arXiv:1910.01213},
  year={2019}
}
```

### Related Work
- **PyPower:** Lincoln, R. (2011). PyPower
- **MATPOWER:** Zimmerman et al. (2011). MATPOWER: Steady-State Operations, Planning and Analysis Tools
- **IEEE Test Cases:** Power Systems Test Case Archive

---

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## ğŸ¤ Contributing

Contributions are welcome! Areas for improvement:

1. **Larger Networks:** Test on IEEE 118-bus, 300-bus systems
2. **GPU Optimization:** Batch processing for multiple scenarios
3. **Parallel Computing:** Distributed power flow solving
4. **Extended Constraints:** Line flow limits, voltage angle differences
5. **Online Learning:** Adapt to changing network conditions

Please open an issue or submit a pull request.

---

## ğŸ‘¥ Authors

- Your Name - Implementation and Analysis
- Based on work by Ahmed S. Zamzam & Kyri Baker (2019)

---

## ğŸ™ Acknowledgments

- National Renewable Energy Laboratory (NREL) for original research
- PyPower development team
- IEEE for providing test case data

---

## ğŸ“§ Contact

For questions or issues, please open a GitHub issue or contact [your-email@example.com]

---


---

*Last Updated: November 30, 2025*
